 const PC_LIGHT_THEME_PALETTE={name:"light", backgroundColor:'#FFFFFF', axisColor:'#666666', gridColor:'#E0E0E0', labelColor:'#333333', titleColor:'#333333', legendColor:'#333333', tooltipBgColor:'rgba(0,0,0,0.85)', tooltipColor:'#FFFFFF', defaultDatasetColors:[ '#007bff','#28a745','#dc3545','#ffc107','#17a2b8','#6f42c1', '#e83e8c','#fd7e14','#20c997','#6610f2' ], bar:{borderColorDarkenPercent:20,}, line:{}, annotations:{}};const PC_DARK_THEME_PALETTE={name:"dark", backgroundColor:'#22272E', axisColor:'#ADBAC7', gridColor:'#444C56', labelColor:'#F0F6FC', titleColor:'#F0F6FC', legendColor:'#F0F6FC', tooltipBgColor:'rgba(20,20,25,0.85)', tooltipColor:'#F0F6FC', defaultDatasetColors:[ '#58A6FF','#52D57B','#F87171','#FDB863','#6CBBEB','#B197FC', '#F781BE','#FFA94D','#48D2A0','#A371F7' ], bar:{borderColorDarkenPercent:0,borderColorLightenPercent:20}, line:{}, annotations:{}};class PureChart{constructor(elementId,userOptions){const canvas=document.getElementById(elementId);if(!canvas||canvas.tagName !=='CANVAS'){console.error(`PureChart Error:Element with id "${elementId}"not found or is not a canvas.`);this.isValid=false;return;} this.isValid=true;this.canvas=canvas;this.ctx=this.canvas.getContext('2d');this.initialCanvasWidth=this.canvas.getAttribute('width')? parseInt(this.canvas.getAttribute('width'),10):0;this.initialCanvasHeight=this.canvas.getAttribute('height')? parseInt(this.canvas.getAttribute('height'),10):0;this.interactiveElements=[];this.interactiveLegendItems=[];this.activeTooltipData=null;this.resizeObserver=null;this.debouncedResize=null;const defaults={width:this.initialCanvasWidth||300,height:this.initialCanvasHeight||150,type:'bar', theme:'light', data:{}, options:{autosize:true, padding:{top:20,right:20,bottom:40,left:20}, yAxes:[{id:'left',position:'left',display:true, beginAtZero:true,title:'', displayTitle:true, maxTicks:5, gridLines:true, labelFont:'10px Arial', titleFont:'12px Arial bold', color:'#666',sampleLabelForWidthEstimation:"-9,999.9"}], xAxis:{display:true,title:'',displayTitle:true,gridLines:false,labelFont:'10px Arial',titleFont:'12px Arial bold',color:'#666'}, title:{display:true,text:'',font:'18px Arial bold',color:'#333',padding:15}, legend:{display:true,position:'top',font:'12px Arial',color:'#333',padding:10,markerSize:12,markerStyle:'square'}, bar:{itemSpacingFactor:0.1, groupSpacingFactor:0.2, defaultBorderWidth:1, borderDarkenPercent:20, topCornerRadius:0,averageLine:{display:false, color:'#888', lineWidth:1, dashPattern:[3,3], label:{display:true, font:'10px Arial', color:'#555', position:'above-right', padding:2, backgroundColor:'rgba(255,255,255,0.7)', formatter:(value)=>{if(value===null||value===undefined)return 'Avg:N/A';let avgStr=value.toLocaleString('en-US',{minimumFractionDigits:2,maximumFractionDigits:2});avgStr=avgStr.replace(/,/g,' ');return `Avg:${avgStr}`;}} }}, line:{pointRadius:3, lineWidth:2, tension:0, pointStyle:'circle', averageLine:{display:false, color:'#888', lineWidth:1, dashPattern:[3,3], label:{display:true, font:'10px Arial', color:'#555', position:'above-right', padding:2, backgroundColor:'rgba(255,255,255,0.7)', formatter:(value)=>{if(value===null||value===undefined)return 'Avg:N/A';let avgStr=value.toLocaleString('en-US',{minimumFractionDigits:2,maximumFractionDigits:2});avgStr=avgStr.replace(/,/g,' ');return `Avg:${avgStr}`;}} }}, percentageDistribution:{barHeight:20,barSpacing:3,barBorderRadius:4,labelFont:'12px Arial', labelColor:'#333',valueFont:'12px Arial bold',valueColor:'#333', showValueText:true,labelPosition:'left',valuePosition:'right', colors:null, maxLabelWidth:100,valueTextMargin:8,sort:'none',borderWidth:1, borderColor:undefined, borderDarkenPercent:20, fillLightenPercent:undefined,valuesArePercentages:false}, gridColor:'#e0e0e0', tooltip:{enabled:true, backgroundColor:'rgba(0,0,0,0.85)', color:'white', font:'12px Arial', padding:'10px', borderRadius:'5px', offset:10, formatter:(params)=>{if(!params)return '';if(params.type==='percentageDistribution' &&params.item){let itemValueStr=params.item.value.toLocaleString('en-US').replace(/,/g,' ');return `<div style="text-align:left;"><strong>${params.item.label}</strong><br/>Value:${itemValueStr}<br/>Percentage:${params.item.percentage.toFixed(1)}%</div>`;} let html=`<div style="font-weight:bold;margin-bottom:5px;text-align:left;">${params.xLabel||''}</div>`;(params.datasets||[]).forEach((item)=>{if(item &&item.dataset){let markerColor=item.dataset.color;if(!markerColor){markerColor=item.dataset.borderColor|| (Array.isArray(item.dataset.backgroundColor)? item.dataset.backgroundColor[0]:item.dataset.backgroundColor);} if(!markerColor &&params.themePalette){const originalIndex=item.dataset.originalIndex !==undefined ? item.dataset.originalIndex:0;markerColor=params.themePalette.defaultDatasetColors[originalIndex % params.themePalette.defaultDatasetColors.length];} markerColor=markerColor||'#ccc';let valStr=(item.value !==undefined &&item.value !==null)? item.value.toLocaleString('en-US').replace(/,/g,' '): 'N/A';html+=`<div style="text-align:left;">`+ `<span style="display:inline-block;width:10px;height:10px;border-radius:50%;background-color:${markerColor};margin-right:5px;"></span>`+ `${item.dataset.label||'Dataset'}:${valStr}`+ `</div>`;}});return html;}}, periodHighlights:{display:false,legendLabel:"Periods",periods:[],defaultStyle:{fillColor:'rgba(255,0,0,0.1)',borderColor:'rgba(255,0,0,0.3)',borderWidth:1,label:{font:'10px Arial',color:'#000000',angle:-30,position:'above',offset:5,textAlign:'center'}} }} };this.config=PureChart._mergeDeep(defaults,userOptions);this.showPeriodHighlights=this.config.options.periodHighlights &&this.config.options.periodHighlights.display;if(this.config.options.autosize){const parentElement=this.canvas.parentElement;if(parentElement){this.debouncedResize=PureChart._debounce(this._handleResize.bind(this),250);this.resizeObserver=new ResizeObserver(entries=>{for(let entry of entries){this.debouncedResize(entry.contentRect);}});this.resizeObserver.observe(parentElement);this._handleResize(parentElement.getBoundingClientRect());}else{console.error("PureChart Autosize Error:Canvas parent element not found. Autosize disabled for this instance.");this.config.options.autosize=false}} const defaultSingleYAxisConfig=defaults.options.yAxes[0];if(this.config.options.yAxis &&(!userOptions.options?.yAxes||userOptions.options.yAxes===undefined)){const userSingularYAxisConfig=this.config.options.yAxis;let base=PureChart._mergeDeep({},defaultSingleYAxisConfig);this.config.options.yAxes=[ PureChart._mergeDeep(base,userSingularYAxisConfig)];delete this.config.options.yAxis;}else if(this.config.options.yAxes &&Array.isArray(this.config.options.yAxes)){this.config.options.yAxes=this.config.options.yAxes.map(eachUserAxisConfig=>{let base=PureChart._mergeDeep({},defaultSingleYAxisConfig);return PureChart._mergeDeep(base,eachUserAxisConfig);});}else{this.config.options.yAxes=[ PureChart._mergeDeep({},defaultSingleYAxisConfig)];} if(this.config.options.yAxes &&Array.isArray(this.config.options.yAxes)){this.config.options.yAxes.forEach((axis,index)=>{if(!axis.id){axis.id=index===0 ? 'left':`yAxis-${index}`} if(!axis.position){axis.position=index===0 ? 'left':(index===1 ? 'right':'left')}});} if(typeof this.config.theme==='object' &&this.config.theme !==null){const basePaletteName=this.config.theme.extends;let basePaletteInstance;if(basePaletteName==='dark'){basePaletteInstance=PC_DARK_THEME_PALETTE;}else{basePaletteInstance=PC_LIGHT_THEME_PALETTE;} this.activePalette=PureChart._mergeDeep({},basePaletteInstance);this.activePalette=PureChart._mergeDeep(this.activePalette,this.config.theme);for(const key in basePaletteInstance){if(this.activePalette[key]===undefined &&basePaletteInstance.hasOwnProperty(key)&&typeof basePaletteInstance[key] !=='object'){this.activePalette[key]=basePaletteInstance[key];}else if(typeof basePaletteInstance[key]==='object' &&basePaletteInstance[key] !==null &&!Array.isArray(basePaletteInstance[key])){if(!this.activePalette[key])this.activePalette[key]={};this.activePalette[key]=PureChart._mergeDeep({},basePaletteInstance[key],this.activePalette[key]);}} if(!this.activePalette.name)this.activePalette.name=basePaletteInstance.name;}else if(this.config.theme==='dark'){this.activePalette={...PC_DARK_THEME_PALETTE}}else{this.activePalette={...PC_LIGHT_THEME_PALETTE}} if(this.config.data &&this.config.data.datasets &&this.config.options.yAxes &&this.config.options.yAxes.length >0){const defaultYAxisID=this.config.options.yAxes[0].id;this.config.data.datasets.forEach(dataset=>{if(dataset.yAxisID===undefined){dataset.yAxisID=defaultYAxisID;}});} this._validateConfig();if(!this.isValid)return;this.canvas.width=this.config.width;this.canvas.height=this.config.height;if(this.isValid &&this.config.options.tooltip.enabled){this._createTooltipElement();this._boundOnMouseMove=this._onMouseMove.bind(this);this._boundOnMouseOut=this._onMouseOut.bind(this);this.canvas.addEventListener('mousemove',this._boundOnMouseMove);this.canvas.addEventListener('mouseout',this._boundOnMouseOut);this.canvas.addEventListener('mouseleave',this._boundOnMouseOut);} if(this.config.data &&this.config.data.datasets){this.config.data.datasets.forEach(dataset=>{dataset._hidden=false;});} this._boundOnCanvasClick=this._onCanvasClick.bind(this);this.canvas.addEventListener('click',this._boundOnCanvasClick);this._draw();} static _debounce(func,delay){let timeout;return function(...args){const context=this;clearTimeout(timeout);timeout=setTimeout(()=>func.apply(context,args),delay);};} _handleResize(newRect){if(!this.isValid){return;} if(!newRect)return;let newCanvasWidth=Math.floor(newRect.width);let newCanvasHeight=Math.floor(newRect.height);if(this.initialCanvasWidth >0){newCanvasWidth=Math.min(newCanvasWidth,this.initialCanvasWidth);} if(this.initialCanvasHeight >0){newCanvasHeight=Math.min(newCanvasHeight,this.initialCanvasHeight);} if(this.canvas.width !==newCanvasWidth||this.canvas.height !==newCanvasHeight){this.canvas.width=newCanvasWidth;this.canvas.height=newCanvasHeight;this.config.width=newCanvasWidth;this.config.height=newCanvasHeight;this._draw()}} static _calculateSMA(dataValues,period){if(!dataValues||period <=0||dataValues.length===0){return [];} if(dataValues.length <period){return new Array(dataValues.length).fill(null)} const smaValues=[];for(let i=0;i <=dataValues.length-period;i++){let sum=0;let numbersInPeriod=0;for(let j=0;j <period;j++){if(typeof dataValues[i+j]==='number' &&!isNaN(dataValues[i+j])){sum+=dataValues[i+j];numbersInPeriod++;}} smaValues.push(numbersInPeriod >0 ? sum / numbersInPeriod:null);} const padding=new Array(period-1).fill(null);return padding.concat(smaValues);} static _calculateDatasetAverage(values){if(!Array.isArray(values)){return null;} const numericValues=values.filter(v=>typeof v==='number' &&!isNaN(v));if(numericValues.length===0){return null;} const sum=numericValues.reduce((acc,val)=>acc+val,0);return sum / numericValues.length;} static _mergeDeep(target,source){const isObject=(obj)=>obj &&typeof obj==='object' &&!Array.isArray(obj);let output={...target};if(isObject(target)&&isObject(source)){Object.keys(source).forEach(key=>{if(isObject(source[key])){if(!(key in target)||!isObject(target[key])){output[key]={...source[key]}}else{output[key]=PureChart._mergeDeep(target[key],source[key]);}}else{output[key]=source[key]}});} return output;} static async fromJSON(elementId,jsonUrl,overrideOptions={},csrfToken=null){try{const fetchOptions={};if(csrfToken){fetchOptions.headers={'X-CSRFToken':csrfToken };} const response=await fetch(jsonUrl,fetchOptions);if(!response.ok){console.error(`PureChart Fetch Error:Status ${response.status}for URL ${jsonUrl}`);throw new Error(`PureChart Error:Failed to fetch JSON from ${jsonUrl}. Status:${response.status}`);} const jsonConfigFromApi=await response.json();let chartSpecificConfig=jsonConfigFromApi;if(jsonConfigFromApi &&typeof jsonConfigFromApi.chart_datas==='object' &&jsonConfigFromApi.chart_datas !==null){chartSpecificConfig=jsonConfigFromApi.chart_datas;} let finalConfig={};finalConfig=PureChart._mergeDeep(chartSpecificConfig,overrideOptions);const canvasForCheck=document.getElementById(elementId);if(canvasForCheck){if(!finalConfig.width &&canvasForCheck.width)finalConfig.width=canvasForCheck.width;if(!finalConfig.height &&canvasForCheck.height)finalConfig.height=canvasForCheck.height;} return new PureChart(elementId,finalConfig);}catch(error){console.error("PureChart Error(fromJSON catch block):",error);const canvas=document.getElementById(elementId);if(canvas &&canvas.getContext){const ctx=canvas.getContext('2d');ctx.clearRect(0,0,canvas.width,canvas.height);ctx.font='12px Arial';ctx.fillStyle='red';ctx.textAlign='center';const message=`Error loading chart from JSON:${String(error.message).substring(0,100)}`;String(message).split('n').forEach((line,index)=>{ctx.fillText(line,canvas.width / 2,canvas.height / 2-(String(message).split('n').length-1)*7+index * 14);});} return null}} _validateConfig(){if(this.config.type==='percentageDistribution'){if(!this.config.data||!Array.isArray(this.config.data.items)||this.config.data.items.length===0){console.error("PureChart Error(percentageDistribution):data.items array is required and non-empty.");this.isValid=false;return;} if(this.isValid){this.config.data.items.forEach((item,index)=>{if(item===null||typeof item !=='object'||typeof item.label !=='string'||typeof item.value !=='number'||item.value <0||isNaN(item.value)){console.error(`PureChart Error(percentageDistribution):Item ${index}is invalid. Must be{label:string,value:non-negative number}. Item:`,item);this.isValid=false}});} if(!this.isValid)return;if(this.config.options.percentageDistribution &&this.config.options.percentageDistribution.valuesArePercentages){this.config.data.items.forEach((item,index)=>{if(typeof item.value==='number' &&!isNaN(item.value)&&(item.value <0||item.value >100)){console.warn(`PureChart Warning(percentageDistribution):Item '${item.label||`Index ${index}`}' has value ${item.value}which is outside the expected 0-100 range when valuesArePercentages is true.`);}});} this.config.options.xAxis.display=this.config.options.xAxis.display ?? false;if(this.config.options.yAxes &&this.config.options.yAxes.length >0){this.config.options.yAxes[0].display=this.config.options.yAxes[0].display ?? false;} this.config.options.legend.display=this.config.options.legend.display ?? false;}else{if(!this.config.data||!this.config.data.labels||!this.config.data.datasets){console.error("PureChart Error(bar/line):data.labels and data.datasets are required.");this.isValid=false;return;} if(this.isValid){this.config.data.datasets.forEach((ds,index)=>{const datasetEffectiveType=ds.type||this.config.type;if(datasetEffectiveType !=='sma'){if(!ds.values||!Array.isArray(ds.values)){console.error(`PureChart Error(bar/line):Dataset ${index}('${ds.label||'Untitled'}')missing 'values' array.`);this.isValid=false;}} if((datasetEffectiveType==='line'||datasetEffectiveType==='sma')&&ds.fill===undefined){ds.fill=false;}});} if(!this.isValid)return;}} _resolveColor(colorOption,elementRect){if(typeof colorOption==='function')return colorOption(this.ctx,elementRect);if(Array.isArray(colorOption)&&colorOption.length >=2){const gradient=this.ctx.createLinearGradient(elementRect.x,elementRect.y,elementRect.x,elementRect.y+elementRect.h);gradient.addColorStop(0,colorOption[0]);gradient.addColorStop(1,colorOption[1]);return gradient;} return colorOption||'#007bff'} _darkenColor(colorStr,percent){if(typeof colorStr !=='string')return '#333333';let r,g,b,a=1;const factor=1-(percent / 100);if(colorStr.startsWith('rgba')){const parts=colorStr.match(/[d.]+/g);if(parts &&parts.length >=3){r=parseInt(parts[0]);g=parseInt(parts[1]);b=parseInt(parts[2]);a=parts.length >=4 ? parseFloat(parts[3]):1}else{return '#333333'}} else if(colorStr.startsWith('rgb')){const parts=colorStr.match(/d+/g);if(parts &&parts.length >=3){r=parseInt(parts[0]);g=parseInt(parts[1]);b=parseInt(parts[2])}else{return '#333333'}} else if(colorStr.startsWith('#')){let hex=colorStr.slice(1);if(hex.length===3)hex=hex.split('').map(char=>char+char).join('');if(hex.length===6){const num=parseInt(hex,16);r=(num >>16)&255;g=(num >>8)&255;b=num &255}else{return '#333333'}} else{return '#333333'} r=Math.max(0,Math.floor(r * factor));g=Math.max(0,Math.floor(g * factor));b=Math.max(0,Math.floor(b * factor));return `rgba(${r},${g},${b},${a})`;} _lightenColor(colorStr,percent){if(typeof colorStr !=='string')return '#EEEEEE';let r,g,b,a=1;const factor=percent / 100;if(colorStr.startsWith('rgba')){const parts=colorStr.match(/[d.]+/g);if(parts &&parts.length >=3){r=parseInt(parts[0]);g=parseInt(parts[1]);b=parseInt(parts[2]);a=parts.length >=4 ? parseFloat(parts[3]):1}else{return '#EEEEEE'}} else if(colorStr.startsWith('rgb')){const parts=colorStr.match(/d+/g);if(parts &&parts.length >=3){r=parseInt(parts[0]);g=parseInt(parts[1]);b=parseInt(parts[2])}else{return '#EEEEEE'}} else if(colorStr.startsWith('#')){let hex=colorStr.slice(1);if(hex.length===3)hex=hex.split('').map(char=>char+char).join('');if(hex.length===6){const num=parseInt(hex,16);r=(num >>16)&255;g=(num >>8)&255;b=num &255}else{return '#EEEEEE'}} else{try{const tempCtx=this.canvas.getContext('2d');tempCtx.fillStyle=colorStr;const parsedColor=tempCtx.fillStyle;if(parsedColor.startsWith('#')||parsedColor.startsWith('rgb'))return this._lightenColor(parsedColor,percent)}catch(e){} return '#EEEEEE'} r=Math.min(255,Math.floor(r+(255-r)* factor));g=Math.min(255,Math.floor(g+(255-g)* factor));b=Math.min(255,Math.floor(b+(255-b)* factor));return `rgba(${r},${g},${b},${a})`;} _getAutoColor(index,totalItems){const colors=this.config.options.percentageDistribution.colors;if(colors &&colors[index % colors.length])return colors[index % colors.length];const hue=Math.round((index *(360 /(totalItems >1 ? totalItems:2)))% 360);return `hsl(${hue},70%,55%)`;} _getDrawingArea(){let{top:paddingTop,right:paddingRight,bottom:paddingBottom,left:paddingLeft}={...this.config.options.padding};const options=this.config.options;let currentTop=paddingTop;let currentRight=paddingRight;let currentBottom=paddingBottom;let currentLeft=paddingLeft;if(options.title.display &&options.title.text){this.ctx.font=options.title.font;currentTop+=(this.ctx.measureText('M').width * 1.5)+options.title.padding} if(options.legend.display &&this.config.type !=='percentageDistribution'){this.ctx.font=options.legend.font;const legendHeight=((this.ctx.measureText('M').width * 1.5)+options.legend.padding)* 2.1;if(options.legend.position==='top'){currentTop+=legendHeight;}else{currentBottom+=legendHeight;}} if(this.config.type !=='percentageDistribution'){let dynamicLeftPadding=0;let dynamicRightPadding=0;if(options.yAxes &&Array.isArray(options.yAxes)){options.yAxes.forEach(axisConfig=>{if(axisConfig.display){let axisSpace=0;this.ctx.font=axisConfig.labelFont;axisSpace+=this.ctx.measureText(axisConfig.sampleLabelForWidthEstimation||"-9,999.9").width+10;if(axisConfig.displayTitle &&axisConfig.title){const originalFont=this.ctx.font;this.ctx.font=axisConfig.titleFont;axisSpace+=(this.ctx.measureText('M').width * 1.5)+5;this.ctx.font=originalFont} if(axisConfig.position==='right'){dynamicRightPadding+=axisSpace;}else{dynamicLeftPadding+=axisSpace;}} });} currentLeft+=dynamicLeftPadding;currentRight+=dynamicRightPadding;if(options.xAxis.display){this.ctx.font=options.xAxis.labelFont;currentBottom+=(this.ctx.measureText('M').width * 1.5)+5;if(options.xAxis.displayTitle &&options.xAxis.title){const originalFont=this.ctx.font;this.ctx.font=options.xAxis.titleFont;currentBottom+=(this.ctx.measureText('M').width * 1.5)+5;this.ctx.font=originalFont;}} }else{this.ctx.font=options.percentageDistribution.labelFont;if(options.percentageDistribution.labelPosition==='left'){currentLeft=Math.max(currentLeft,(options.percentageDistribution.maxLabelWidth||0)+10);} this.ctx.font=options.percentageDistribution.valueFont;if(options.percentageDistribution.showValueText &&options.percentageDistribution.valuePosition==='right'){currentRight=Math.max(currentRight,this.ctx.measureText("100.0%").width+(options.percentageDistribution.valueTextMargin||0)+5);}} currentTop=Math.max(5,currentTop);currentRight=Math.max(5,currentRight);currentBottom=Math.max(5,currentBottom);currentLeft=Math.max(5,currentLeft);const drawWidth=this.canvas.width-currentLeft-currentRight;const drawHeight=this.canvas.height-currentTop-currentBottom;return{x:currentLeft,y:currentTop,width:drawWidth >0 ? drawWidth:0,height:drawHeight >0 ? drawHeight:0};} _createTooltipElement(){if(this.tooltipElement||!this.config.options.tooltip.enabled)return;this.tooltipElement=document.createElement('div');this.tooltipElement.style.position='absolute';this.tooltipElement.style.visibility='hidden';this.tooltipElement.style.pointerEvents='none';this.tooltipElement.style.zIndex='100';const tO=this.config.options.tooltip;this.tooltipElement.style.backgroundColor=tO.backgroundColor;this.tooltipElement.style.color=tO.color;this.tooltipElement.style.font=tO.font;this.tooltipElement.style.padding=tO.padding;this.tooltipElement.style.borderRadius=tO.borderRadius;this.tooltipElement.style.boxShadow='0 2px 5px rgba(0,0,0,0.2)';document.body.appendChild(this.tooltipElement);} _draw(){if(!this.isValid){return;} if(!this.activePalette){if(this.config &&this.config.theme){if(this.config.theme==='dark'){this.activePalette={...PC_DARK_THEME_PALETTE};}else if(typeof this.config.theme==='object' &&this.config.theme !==null){const basePaletteName=this.config.theme.extends;let basePaletteInstance;if(basePaletteName==='dark'){basePaletteInstance=PC_DARK_THEME_PALETTE;}else{basePaletteInstance=PC_LIGHT_THEME_PALETTE;} this.activePalette=PureChart._mergeDeep({},basePaletteInstance,this.config.theme);for(const key in basePaletteInstance){if(this.activePalette[key]===undefined &&basePaletteInstance.hasOwnProperty(key)&&typeof basePaletteInstance[key] !=='object'){this.activePalette[key]=basePaletteInstance[key];}else if(typeof basePaletteInstance[key]==='object' &&basePaletteInstance[key] !==null &&!Array.isArray(basePaletteInstance[key])){if(!this.activePalette[key])this.activePalette[key]={};this.activePalette[key]=PureChart._mergeDeep({},basePaletteInstance[key],this.activePalette[key]);}} if(!this.activePalette.name)this.activePalette.name=basePaletteInstance.name;}else{this.activePalette={...PC_LIGHT_THEME_PALETTE};}}else{console.error("PureChart:Cannot initialize activePalette in _draw due to missing config or theme. Using light theme as emergency fallback.");this.activePalette={...PC_LIGHT_THEME_PALETTE};}} this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);this.ctx.textBaseline='middle';this.interactiveElements=[];this._preprocessDatasetValues();this.drawArea=this._getDrawingArea();if(this.drawArea.width <=0||this.drawArea.height <=0){console.warn("PureChart Warning:Drawing area too small.");this.ctx.font='12px Arial';this.ctx.fillStyle='#333';this.ctx.textAlign='center';this.ctx.fillText("Drawing area too small.",this.canvas.width / 2,this.canvas.height / 2);return;} if(this.config.type !=='percentageDistribution'){this._calculateScale();if(!this.isValid){console.error("PureChart:Scale calculation failed.");this.ctx.font='12px Arial';this.ctx.fillStyle='red';this.ctx.textAlign='center';this.ctx.fillText("Error:Scale calculation failed.",this.canvas.width / 2,this.canvas.height / 2);return;}} if(this.config.options.title.display &&this.config.options.title.text)this._drawTitle();if(this.config.type==='percentageDistribution')this._drawPercentageBarChart();else{if(this.config.options.legend.display)this._drawLegend();this._drawAxesAndGrid();this._drawPeriodHighlights();if(this.config.options.yAxes &&this.config.options.yAxes.length >0 &&this.yAxisScales &&Object.keys(this.yAxisScales).length >0){this._drawAnnotations();} this._drawBarChart();this._drawLineChart();this._drawAverageLines();}} _drawAverageLines(){if(!this.config.data||!this.config.data.datasets||this.config.type==='percentageDistribution'||!this.yAxisScales){return;} this.ctx.save();this.config.data.datasets.forEach(dataset=>{const datasetType=dataset.type||this.config.type;if(dataset._hidden||datasetType==='percentageDistribution'||datasetType==='sma'){return;} const yAxisID=dataset.yAxisID||(this.config.options.yAxes &&this.config.options.yAxes.length >0 ? this.config.options.yAxes[0].id:null);if(!yAxisID){return;} const yAxisScaleInfo=this.yAxisScales[yAxisID];if(!yAxisScaleInfo||!yAxisScaleInfo.scale||yAxisScaleInfo.scale <=0||!isFinite(yAxisScaleInfo.scale)||!yAxisScaleInfo.axisConfig.display){return;} const defaultAvgLineConfig=(this.config.options[datasetType] &&this.config.options[datasetType].averageLine) ? this.config.options[datasetType].averageLine :{};const datasetAvgLineConfig=dataset.averageLine||{};const avgLineCfg=PureChart._mergeDeep(defaultAvgLineConfig,datasetAvgLineConfig);if(!avgLineCfg.display){return;} const averageValue=PureChart._calculateDatasetAverage(dataset.values);if(averageValue===null){return;} let y=this.drawArea.y+this.drawArea.height-((averageValue-(yAxisScaleInfo.min||0))*(yAxisScaleInfo.scale||1));y=Math.max(this.drawArea.y,Math.min(y,this.drawArea.y+this.drawArea.height));this.ctx.save();this.ctx.beginPath();this.ctx.moveTo(this.drawArea.x,y);this.ctx.lineTo(this.drawArea.x+this.drawArea.width,y);this.ctx.strokeStyle=avgLineCfg.color;this.ctx.lineWidth=avgLineCfg.lineWidth;if(Array.isArray(avgLineCfg.dashPattern)&&avgLineCfg.dashPattern.length >0){this.ctx.setLineDash(avgLineCfg.dashPattern);} this.ctx.stroke();if(Array.isArray(avgLineCfg.dashPattern)&&avgLineCfg.dashPattern.length >0){this.ctx.setLineDash([])} this.ctx.restore();if(avgLineCfg.label &&avgLineCfg.label.display &&avgLineCfg.label.formatter){this.ctx.save();const labelCfg=avgLineCfg.label;const labelText=typeof labelCfg.formatter==='function' ? labelCfg.formatter(averageValue):String(averageValue);this.ctx.font=labelCfg.font;this.ctx.fillStyle=labelCfg.color;let labelX,labelY;const padding=labelCfg.padding||0;const textMetrics=this.ctx.measureText(labelText);const fontHeight=parseInt(this.ctx.font.match(/(d+)px/)?.[1]||'10');let textAlign='right';let textBaseline='bottom';labelX=this.drawArea.x+this.drawArea.width-padding;labelY=y-padding;if(labelCfg.position==='above-left'){textAlign='left';labelX=this.drawArea.x+padding;}else if(labelCfg.position==='below-left'){textAlign='left';textBaseline='top';labelX=this.drawArea.x+padding;labelY=y+padding;}else if(labelCfg.position==='below-right'){textAlign='right';textBaseline='top';labelX=this.drawArea.x+this.drawArea.width-padding;labelY=y+padding;} this.ctx.textAlign=textAlign;this.ctx.textBaseline=textBaseline;if(labelCfg.backgroundColor){const bgWidth=textMetrics.width+(padding * 2);const bgHeight=fontHeight+(padding * 2);let bgX=labelX;let bgY=labelY;if(textAlign==='right')bgX=labelX-textMetrics.width-padding;else if(textAlign==='center')bgX=labelX-textMetrics.width / 2-padding;else bgX=labelX-padding;if(textBaseline==='bottom')bgY=labelY-fontHeight-padding;else if(textBaseline==='middle')bgY=labelY-fontHeight / 2-padding;else bgY=labelY-padding;this.ctx.fillStyle=labelCfg.backgroundColor;this.ctx.fillRect(bgX,bgY,bgWidth,bgHeight);this.ctx.fillStyle=labelCfg.color} this.ctx.fillText(labelText,labelX,labelY);this.ctx.restore();}});this.ctx.restore();} _drawTitle(){const{text,font,color,padding}=this.config.options.title;this.ctx.save();this.ctx.font=font;this.ctx.fillStyle=color;this.ctx.textAlign='center';this.ctx.textBaseline='top';this.ctx.fillText(text,this.canvas.width / 2,padding);this.ctx.restore();} _drawLegend(){const{data,options}=this.config;const{legend}=options;if(!data.datasets||data.datasets.length===0)return;this.ctx.save();this.interactiveLegendItems=[];this.ctx.font=legend.font;this.ctx.fillStyle=legend.color;this.ctx.textAlign='left';this.ctx.textBaseline='middle';const markerSize=legend.markerSize;const itemHeight=Math.max(markerSize,this.ctx.measureText('M').width*1.2);const itemSpacing=5;let currentX,currentY;let titleActualHeight=options.padding.top;if(options.title.display &&options.title.text){const tempFont=this.ctx.font;this.ctx.font=options.title.font;titleActualHeight=(this.ctx.measureText('M').width*1.5)+options.title.padding+options.padding.top;this.ctx.font=tempFont} if(legend.position==='top')currentY=titleActualHeight+legend.padding+(itemHeight/2);else currentY=this.canvas.height-options.padding.bottom-legend.padding-(itemHeight/2);const legendItemsData=data.datasets.map((ds,index)=>({label:ds.label||`Dataset ${index+1}`,color:ds.borderColor||(Array.isArray(ds.backgroundColor)? ds.backgroundColor[0]:ds.backgroundColor)||'#ccc', textWidth:this.ctx.measureText(ds.label||`Dataset ${index+1}`).width,dataset:ds, datasetIndex:index }));if(this.config.options.periodHighlights &&this.config.options.periodHighlights.periods &&this.config.options.periodHighlights.periods.length >0 &&this.config.options.periodHighlights.legendLabel){const phLegendLabel=this.config.options.periodHighlights.legendLabel;const phColor=this.config.options.periodHighlights.defaultStyle?.fillColor||'#888888';legendItemsData.push({label:phLegendLabel, color:phColor, textWidth:this.ctx.measureText(phLegendLabel).width, isPeriodToggle:true, dataset:{_hidden:!this.showPeriodHighlights}});} const totalLegendItemWidth=legendItemsData.reduce((sum,item)=>sum+markerSize+5+item.textWidth+15,0)-15;currentX=Math.max(this.drawArea.x,this.drawArea.x+(this.drawArea.width-totalLegendItemWidth)/ 2);const maxLegendX=this.drawArea.x+this.drawArea.width;legendItemsData.forEach(item=>{const itemSegmentStartX=currentX;const itemSegmentWidth=markerSize+5+item.textWidth+15;if(currentX+itemSegmentWidth >maxLegendX &&currentX >Math.max(this.drawArea.x,this.drawArea.x+(this.drawArea.width-totalLegendItemWidth)/ 2)){currentY+=itemHeight+itemSpacing;currentX=Math.max(this.drawArea.x,this.drawArea.x+(this.drawArea.width-totalLegendItemWidth)/ 2);} if(currentX <this.drawArea.x)currentX=this.drawArea.x;const markerX=currentX;const textX=markerX+markerSize+5;const legendItemRect={x:markerX, y:currentY-itemHeight / 2, w:itemSegmentWidth, h:itemHeight };this.interactiveLegendItems.push({rect:legendItemRect,dataset:item.dataset,datasetIndex:item.datasetIndex,isPeriodToggle:item.isPeriodToggle||false});this.ctx.fillStyle=item.color;if(legend.markerStyle==='circle'){this.ctx.beginPath();this.ctx.arc(markerX+markerSize / 2,currentY,markerSize / 2,0,Math.PI * 2);this.ctx.fill();}else{this.ctx.fillRect(markerX,currentY-markerSize / 2,markerSize,markerSize);} const originalFillStyle=this.ctx.fillStyle;if(item.dataset._hidden){this.ctx.fillStyle='#aaa'}else{this.ctx.fillStyle=legend.color} this.ctx.fillText(item.label,textX,currentY);if(item.dataset._hidden){const textWidth=item.textWidth;this.ctx.beginPath();this.ctx.moveTo(textX,currentY);this.ctx.lineTo(textX+textWidth,currentY);this.ctx.strokeStyle='#aaa';this.ctx.lineWidth=1;this.ctx.stroke();} this.ctx.fillStyle=originalFillStyle;currentX+=itemSegmentWidth;});this.ctx.restore();} _onCanvasClick(event){if(!this.interactiveLegendItems||this.interactiveLegendItems.length===0)return;const mousePos=this._getMousePos(event);let legendItemClicked=false;for(const item of this.interactiveLegendItems){if(mousePos.x >=item.rect.x &&mousePos.x <=item.rect.x+item.rect.w &&mousePos.y >=item.rect.y &&mousePos.y <=item.rect.y+item.rect.h){legendItemClicked=true;if(item.isPeriodToggle){this.showPeriodHighlights=!this.showPeriodHighlights;if(item.dataset){item.dataset._hidden=!this.showPeriodHighlights;}}else if(item.dataset){item.dataset._hidden=!item.dataset._hidden;}else{legendItemClicked=false} if(legendItemClicked)break}} if(legendItemClicked){this._draw()}} _calculateScale(){const{data,options}=this.config;this.yAxisScales={};if(!options.yAxes||!Array.isArray(options.yAxes)||options.yAxes.length===0){console.warn("PureChart _calculateScale:No yAxes configured. Chart may not render correctly.");this.minValue=0;this.maxValue=1;this.yScale=this.drawArea.height >0 ? this.drawArea.height:1;this.yAxisScales['default']={min:0,max:1,scale:this.yScale,axisConfig:{id:'default',display:true,beginAtZero:true,position:'left'}};this.isValid=false;return;} options.yAxes.forEach(axisConfig=>{const currentAxisID=axisConfig.id;let allValuesForCurrentAxis=[];if(data.datasets &&data.datasets.length >0){data.datasets.forEach(dataset=>{if(dataset.yAxisID===currentAxisID &&!dataset._hidden){if(dataset.values &&Array.isArray(dataset.values)&&dataset.values.length >0){allValuesForCurrentAxis=allValuesForCurrentAxis.concat(dataset.values.filter(v=>typeof v==='number' &&!isNaN(v)));}} });} let minValue,maxValue;if(allValuesForCurrentAxis.length===0){minValue=0;maxValue=1}else{let actualDataMin=Math.min(...allValuesForCurrentAxis);let actualDataMax=Math.max(...allValuesForCurrentAxis);if(axisConfig.beginAtZero){minValue=Math.min(0,actualDataMin);maxValue=Math.max(0,actualDataMax);}else{minValue=actualDataMin;maxValue=actualDataMax;}} if(minValue===maxValue){if(minValue===0){maxValue=1}else{const buffer=Math.abs(maxValue * 0.1)||1;maxValue+=buffer;if(!axisConfig.beginAtZero){minValue-=buffer;}else{minValue=Math.min(0,minValue-buffer);}} } if(minValue===maxValue){maxValue+=1} let yScale;if(this.drawArea.height <=0){yScale=1;}else if(maxValue-minValue===0){yScale=1;} else{yScale=this.drawArea.height /(maxValue-minValue);} if(!isFinite(yScale)||yScale <=0){console.error(`PureChart _calculateScale:Invalid yScale(${yScale})calculated for yAxis ID '${currentAxisID}'. Defaulting to 1.`);yScale=1;} this.yAxisScales[currentAxisID]={min:minValue, max:maxValue, scale:yScale, axisConfig:axisConfig};});if(options.yAxes.length >0){const firstAxisID=options.yAxes[0].id;const firstAxisScales=this.yAxisScales[firstAxisID];if(firstAxisScales){this.minValue=firstAxisScales.min;this.maxValue=firstAxisScales.max;this.yScale=firstAxisScales.scale;}else{console.error("PureChart _calculateScale:Failed to get scale for the first Y-axis for backward compatibility.");this.minValue=0;this.maxValue=1;this.yScale=1;}}else{this.minValue=0;this.maxValue=1;this.yScale=1;}} _drawAxesAndGrid(){const{options,data}=this.config;this.ctx.save();this.ctx.lineWidth=1;this.ctx.font=options.font;let primaryGridAxisId=null;if(options.yAxes &&Array.isArray(options.yAxes)){for(const axisCfg of options.yAxes){if(axisCfg.display &&axisCfg.gridLines){primaryGridAxisId=axisCfg.id;break}} } if(this.yAxisScales &&typeof this.yAxisScales==='object'){Object.values(this.yAxisScales).forEach(yAxisData=>{const{axisConfig,min:minValue,max:maxValue,scale:yScale}=yAxisData;if(!axisConfig.display||this.drawArea.height <=0||!isFinite(yScale)||yScale <=0){return} const isRightPositioned=axisConfig.position==='right';const axisLineX=isRightPositioned ? this.drawArea.x+this.drawArea.width:this.drawArea.x;const tickLabelPadding=8;this.ctx.strokeStyle=axisConfig.color||this.activePalette.axisColor;this.ctx.fillStyle=axisConfig.color||this.activePalette.axisColor;this.ctx.font=axisConfig.labelFont;this.ctx.beginPath();this.ctx.moveTo(axisLineX,this.drawArea.y);this.ctx.lineTo(axisLineX,this.drawArea.y+this.drawArea.height);this.ctx.stroke();this.ctx.textAlign=isRightPositioned ? 'left':'right';this.ctx.textBaseline='middle';const numTicks=Math.max(2,axisConfig.maxTicks||5);if(maxValue !==undefined &&minValue !==undefined &&(maxValue-minValue !==0)){for(let i=0;i <=numTicks;i++){const value=maxValue-(i *(maxValue-minValue)/ numTicks);const yPos=this.drawArea.y+(i * this.drawArea.height / numTicks);if(yPos >=this.drawArea.y-1 &&yPos <=this.drawArea.y+this.drawArea.height+1){const labelTextX=isRightPositioned ? axisLineX+tickLabelPadding:axisLineX-tickLabelPadding;let labelStr=value.toLocaleString('en-US');labelStr=labelStr.replace(/,/g,' ');this.ctx.fillText(labelStr,labelTextX,yPos);} if(axisConfig.id===primaryGridAxisId &&i >0 &&i <numTicks){if(yPos >this.drawArea.y &&yPos <this.drawArea.y+this.drawArea.height){this.ctx.save();this.ctx.strokeStyle=options.gridColor||this.activePalette.gridColor;this.ctx.lineWidth=0.5;this.ctx.beginPath();this.ctx.moveTo(this.drawArea.x+1,yPos);this.ctx.lineTo(this.drawArea.x+this.drawArea.width,yPos);this.ctx.stroke();this.ctx.restore();}} }}else if(maxValue !==undefined){const labelTextX=isRightPositioned ? axisLineX+tickLabelPadding:axisLineX-tickLabelPadding;let maxLabelStr=maxValue.toLocaleString('en-US');maxLabelStr=maxLabelStr.replace(/,/g,' ');this.ctx.fillText(maxLabelStr,labelTextX,this.drawArea.y+this.drawArea.height / 2);} if(axisConfig.displayTitle &&axisConfig.title){this.ctx.save();this.ctx.font=axisConfig.titleFont;this.ctx.textAlign='center';this.ctx.textBaseline='middle';const tempLabelFont=this.ctx.font;this.ctx.font=axisConfig.labelFont;const sampleYLabelText=axisConfig.sampleLabelForWidthEstimation||(maxValue !==undefined ? maxValue.toLocaleString():"-9,999.9");const yLabelWidthEstimate=this.ctx.measureText(sampleYLabelText).width;this.ctx.font=tempLabelFont;const titleCharHeightApproximation=(this.ctx.measureText('M').width * 1.5);let yTitleX;if(isRightPositioned){yTitleX=axisLineX+yLabelWidthEstimate+tickLabelPadding+(titleCharHeightApproximation / 2)+5;this.ctx.translate(yTitleX,this.drawArea.y+this.drawArea.height / 2);this.ctx.rotate(Math.PI / 2);}else{yTitleX=axisLineX-yLabelWidthEstimate-tickLabelPadding-(titleCharHeightApproximation / 2)-5;this.ctx.translate(yTitleX,this.drawArea.y+this.drawArea.height / 2);this.ctx.rotate(-Math.PI / 2);} this.ctx.fillText(axisConfig.title,0,0);this.ctx.restore();}});} const oX=options.xAxis;let yAxisForXPositionConfig=null;let yScaleInfoForXPosition=null;if(primaryGridAxisId &&this.yAxisScales[primaryGridAxisId] &&this.yAxisScales[primaryGridAxisId].axisConfig.display){yScaleInfoForXPosition=this.yAxisScales[primaryGridAxisId];yAxisForXPositionConfig=yScaleInfoForXPosition.axisConfig;}else{if(options.yAxes &&options.yAxes.length >0){for(const axisCfg of options.yAxes){if(axisCfg.display &&this.yAxisScales[axisCfg.id]){yScaleInfoForXPosition=this.yAxisScales[axisCfg.id];yAxisForXPositionConfig=axisCfg;break;}} }} let xAxisLineY=this.drawArea.y+this.drawArea.height;if(yScaleInfoForXPosition &&yScaleInfoForXPosition.scale >0){const yMin=yScaleInfoForXPosition.min;const yMax=yScaleInfoForXPosition.max;const yScale=yScaleInfoForXPosition.scale;if(yMin <=0 &&yMax >=0){let calculatedZeroPixelY=this.drawArea.y+this.drawArea.height-((0-yMin)* yScale);xAxisLineY=Math.max(this.drawArea.y,Math.min(calculatedZeroPixelY,this.drawArea.y+this.drawArea.height));}else if(yMax <0 &&yAxisForXPositionConfig &&yAxisForXPositionConfig.beginAtZero){xAxisLineY=this.drawArea.y;}} if(oX.display &&this.drawArea.width >0){this.ctx.strokeStyle=oX.color||this.activePalette.axisColor;this.ctx.lineWidth=1;this.ctx.beginPath();this.ctx.moveTo(this.drawArea.x,xAxisLineY);this.ctx.lineTo(this.drawArea.x+this.drawArea.width,xAxisLineY);this.ctx.stroke();if(data.labels &&data.labels.length >0){this.ctx.fillStyle=oX.labelColor||this.activePalette.labelColor||this.activePalette.axisColor;this.ctx.font=oX.labelFont;this.ctx.textBaseline='top';const labels=data.labels;const numLabels=labels.length;const forceShowFirstAndLast=oX.forceShowFirstAndLastLabel !==undefined ? oX.forceShowFirstAndLastLabel:true;let maxLabelsToShow=oX.maxLabelsToShow;const minSpacingBetweenLabels=oX.minSpacingBetweenLabels !==undefined ? oX.minSpacingBetweenLabels:5;const labelYOffset=oX.labelYOffset||8;const labelYPos=xAxisLineY+labelYOffset;let lastDrawnLabelXEnd=-Infinity;const xLabelSlotWidth=numLabels >0 ? this.drawArea.width / numLabels:this.drawArea.width;if(maxLabelsToShow===undefined &&numLabels >0){let totalTextWidth=0;const originalFont=this.ctx.font;this.ctx.font=oX.labelFont;labels.forEach(l=>{totalTextWidth+=this.ctx.measureText(String(l)).width});this.ctx.font=originalFont;const avgLabelWidth=numLabels >0 ? totalTextWidth / numLabels:0;if(avgLabelWidth+minSpacingBetweenLabels >0){maxLabelsToShow=Math.floor(this.drawArea.width /(avgLabelWidth+minSpacingBetweenLabels));}else{maxLabelsToShow=numLabels;} maxLabelsToShow=Math.max(1,maxLabelsToShow);}else if(maxLabelsToShow===undefined &&numLabels===0){maxLabelsToShow=0;} let indexesToDraw=[];if(numLabels >0 &&maxLabelsToShow >0){if(numLabels <=maxLabelsToShow){indexesToDraw=labels.map((_,i)=>i);}else{if(forceShowFirstAndLast){indexesToDraw.push(0);if(numLabels >1){indexesToDraw.push(numLabels-1);}} const remainingSlots=maxLabelsToShow-indexesToDraw.length;if(remainingSlots >0){let availableInnerLabels=[];for(let i=0;i <numLabels;i++){if(!indexesToDraw.includes(i)){availableInnerLabels.push(i);}} if(availableInnerLabels.length >0){const step=Math.max(1,Math.floor(availableInnerLabels.length / remainingSlots));for(let i=0;i <availableInnerLabels.length &&indexesToDraw.length <maxLabelsToShow;i+=step){if(!indexesToDraw.includes(availableInnerLabels[i])){indexesToDraw.push(availableInnerLabels[i]);}} }} indexesToDraw=[...new Set(indexesToDraw)].sort((a,b)=>a-b);}} if(this.config.type==='bar'){this.ctx.textAlign='center';this.ctx.textBaseline='top';this.ctx.fillStyle=oX.labelColor||this.activePalette.labelColor||this.activePalette.axisColor;this.ctx.font=oX.labelFont;const numBarLabels=data.labels.length;if(numBarLabels >0){const groupTotalWidth=this.drawArea.width / numBarLabels;const actualGroupSpacing=groupTotalWidth *(this.config.options.bar.groupSpacingFactor||0.2);const groupDrawableWidth=groupTotalWidth-actualGroupSpacing;for(let i=0;i <numBarLabels;i++){const groupCanvasXStart=this.drawArea.x+(i * groupTotalWidth)+(actualGroupSpacing / 2);const labelXPos=groupCanvasXStart+groupDrawableWidth / 2;const labelText=String(data.labels[i]);this.ctx.font=oX.labelFont;this.ctx.textAlign='center';this.ctx.textBaseline='top';const textMetrics=this.ctx.measureText(labelText);const fontHeightMatch=oX.labelFont.match(/(d+)px/);const fontHeight=fontHeightMatch ? parseInt(fontHeightMatch[1],10):10;const bgPadding={x:3,y:1};const bgWidth=textMetrics.width+bgPadding.x * 2;const bgHeight=fontHeight+bgPadding.y * 2;const bgX=labelXPos-(textMetrics.width / 2)-bgPadding.x;const bgY=labelYPos-bgPadding.y;const originalFillStyleForLabel=this.ctx.fillStyle;this.ctx.fillStyle=(this.activePalette &&this.activePalette.backgroundColor)? this.activePalette.backgroundColor:'white';this.ctx.fillRect(bgX,bgY,bgWidth,bgHeight);this.ctx.fillStyle=originalFillStyleForLabel;this.ctx.fillText(labelText,labelXPos,labelYPos);}} } else if(data.labels &&data.labels.length >0 &&indexesToDraw.length >0){this.ctx.font=oX.labelFont;const initialLabelCandidates=indexesToDraw.map(index=>{const text=String(labels[index]);return{text:text, width:this.ctx.measureText(text).width, originalIndex:index };}).filter(l=>l.width >0);if(initialLabelCandidates.length >0){let currentSubsetToDisplay=[...initialLabelCandidates];let finalLabelsToDraw=[];let calculatedSpacing=0;const minAcceptableSpacing=oX.minSpacingBetweenLabels !==undefined ? oX.minSpacingBetweenLabels:5;while(true){if(currentSubsetToDisplay.length===0){finalLabelsToDraw=[];break;} const totalWidthOfCurrentSubset=currentSubsetToDisplay.reduce((sum,label)=>sum+label.width,0);if(currentSubsetToDisplay.length <=1){finalLabelsToDraw=[...currentSubsetToDisplay];break;} const numberOfGaps=currentSubsetToDisplay.length-1;calculatedSpacing=(this.drawArea.width-totalWidthOfCurrentSubset)/ numberOfGaps;if(calculatedSpacing >=minAcceptableSpacing){finalLabelsToDraw=[...currentSubsetToDisplay];break;}else{if(currentSubsetToDisplay.length <=2 &&forceShowFirstAndLast){finalLabelsToDraw=[...currentSubsetToDisplay];break;} if(currentSubsetToDisplay.length <=1){finalLabelsToDraw=[...currentSubsetToDisplay];break;} let removalIndex=Math.floor(currentSubsetToDisplay.length / 2);if(forceShowFirstAndLast &&currentSubsetToDisplay.length >2){if(removalIndex===0)removalIndex=1;else if(removalIndex===currentSubsetToDisplay.length-1)removalIndex=currentSubsetToDisplay.length-2} if(removalIndex===0 &&currentSubsetToDisplay.length===2 &&forceShowFirstAndLast){}else if(removalIndex >=currentSubsetToDisplay.length-1 &&currentSubsetToDisplay.length >2 &&forceShowFirstAndLast){removalIndex=currentSubsetToDisplay.length-2}else if(removalIndex===0 &&currentSubsetToDisplay.length===1){} if(currentSubsetToDisplay.length >0 &&removalIndex <currentSubsetToDisplay.length &&removalIndex >=0){if(forceShowFirstAndLast &&currentSubsetToDisplay.length===2 &&initialLabelCandidates.length >=2 &&currentSubsetToDisplay[0].originalIndex===initialLabelCandidates[0].originalIndex &&currentSubsetToDisplay[1].originalIndex===initialLabelCandidates[initialLabelCandidates.length-1].originalIndex){finalLabelsToDraw=[...currentSubsetToDisplay];break;} currentSubsetToDisplay.splice(removalIndex,1);}else{finalLabelsToDraw=[...currentSubsetToDisplay];break;}} } if(finalLabelsToDraw.length >0){this.ctx.textAlign='center';this.ctx.textBaseline='top';this.ctx.fillStyle=oX.labelColor||this.activePalette.labelColor||this.activePalette.axisColor;this.ctx.font=oX.labelFont;if(finalLabelsToDraw.length===1){const label=finalLabelsToDraw[0];let xPos=this.drawArea.x+this.drawArea.width / 2;if(label.width >this.drawArea.width){} xPos=Math.max(xPos,this.drawArea.x+label.width / 2);xPos=Math.min(xPos,this.drawArea.x+this.drawArea.width-label.width / 2);if(label.width >this.drawArea.width){xPos=this.drawArea.x+this.drawArea.width / 2} this.ctx.fillText(label.text,xPos,labelYPos);}else{const totalWidthFinal=finalLabelsToDraw.reduce((sum,l)=>sum+l.width,0);const finalSpacing=Math.max(minAcceptableSpacing,(this.drawArea.width-totalWidthFinal)/(finalLabelsToDraw.length-1));let currentX=this.drawArea.x;const requiredWidth=totalWidthFinal+finalSpacing *(finalLabelsToDraw.length-1);if(requiredWidth >this.drawArea.width){} finalLabelsToDraw.forEach((label,k)=>{const xPos=currentX+label.width / 2;const labelText=label.text;const currentTextWidth=label.width;const fontHeightMatch=oX.labelFont.match(/(d+)px/);const fontHeight=fontHeightMatch ? parseInt(fontHeightMatch[1],10):10;const bgPadding={x:3,y:1};const bgWidth=currentTextWidth+bgPadding.x * 2;const bgHeight=fontHeight+bgPadding.y * 2;const bgX=xPos-(currentTextWidth / 2)-bgPadding.x;const bgY=labelYPos-bgPadding.y;const originalFillStyleForLabel=this.ctx.fillStyle;this.ctx.fillStyle=(this.activePalette &&this.activePalette.backgroundColor)? this.activePalette.backgroundColor:'white';this.ctx.fillRect(bgX,bgY,bgWidth,bgHeight);this.ctx.fillStyle=originalFillStyleForLabel;this.ctx.fillText(labelText,xPos,labelYPos);currentX+=currentTextWidth+finalSpacing});}} }} } if(oX.displayTitle &&oX.title){this.ctx.font=oX.titleFont;this.ctx.fillStyle=oX.titleColor||this.activePalette.titleColor||this.activePalette.axisColor;this.ctx.textAlign='center';this.ctx.textBaseline='bottom';this.ctx.fillText(oX.title,this.drawArea.x+this.drawArea.width / 2,this.canvas.height-(options.padding.bottom / 2));}} this.ctx.restore()} _fillRoundRect(ctx,x,y,width,height,radius){if(width <=0||height <=0)return;let tl=0,tr=0,br=0,bl=0;if(typeof radius==='number'){tl=tr=br=bl=Math.max(0,radius);}else if(typeof radius==='object' &&radius !==null){tl=Math.max(0,radius.tl||0);tr=Math.max(0,radius.tr||0);br=Math.max(0,radius.br||0);bl=Math.max(0,radius.bl||0);} const maxRadiusHor=width / 2;const maxRadiusVer=height / 2;tl=Math.min(tl,maxRadiusHor,maxRadiusVer);tr=Math.min(tr,maxRadiusHor,maxRadiusVer);br=Math.min(br,maxRadiusHor,maxRadiusVer);bl=Math.min(bl,maxRadiusHor,maxRadiusVer);if(tl <=0 &&tr <=0 &&br <=0 &&bl <=0){ctx.fillRect(x,y,width,height);return;} ctx.beginPath();ctx.moveTo(x+tl,y);ctx.lineTo(x+width-tr,y);if(tr >0)ctx.arcTo(x+width,y,x+width,y+tr,tr);ctx.lineTo(x+width,y+height-br);if(br >0)ctx.arcTo(x+width,y+height,x+width-br,y+height,br);ctx.lineTo(x+bl,y+height);if(bl >0)ctx.arcTo(x,y+height,x,y+height-bl,bl);ctx.lineTo(x,y+tl);if(tl >0)ctx.arcTo(x,y,x+tl,y,tl);ctx.closePath();ctx.fill();} _strokeRoundRect(ctx,x,y,width,height,radius,lineWidth=1){if(width <=0||height <=0||lineWidth <=0)return;let tl=0,tr=0,br=0,bl=0;if(typeof radius==='number'){tl=tr=br=bl=Math.max(0,radius);}else if(typeof radius==='object' &&radius !==null){tl=Math.max(0,radius.tl||0);tr=Math.max(0,radius.tr||0);br=Math.max(0,radius.br||0);bl=Math.max(0,radius.bl||0);} const maxRadiusHor=width / 2;const maxRadiusVer=height / 2;tl=Math.min(tl,maxRadiusHor,maxRadiusVer);tr=Math.min(tr,maxRadiusHor,maxRadiusVer);br=Math.min(br,maxRadiusHor,maxRadiusVer);bl=Math.min(bl,maxRadiusHor,maxRadiusVer);if(tl <=0 &&tr <=0 &&br <=0 &&bl <=0){ctx.strokeRect(x,y,width,height);return;} ctx.beginPath();ctx.moveTo(x+tl,y);ctx.lineTo(x+width-tr,y);if(tr >0)ctx.arcTo(x+width,y,x+width,y+tr,tr);ctx.lineTo(x+width,y+height-br);if(br >0)ctx.arcTo(x+width,y+height,x+width-br,y+height,br);ctx.lineTo(x+bl,y+height);if(bl >0)ctx.arcTo(x,y+height,x,y+height-bl,bl);ctx.lineTo(x,y+tl);if(tl >0)ctx.arcTo(x,y,x+tl,y,tl);ctx.closePath();ctx.stroke();} _drawPercentageBarChart(){if(!this.config.data||!Array.isArray(this.config.data.items)){console.error("PureChart Error(_drawPercentageBarChart):data.items is missing or not an array.");this.ctx.font='12px Arial';this.ctx.fillStyle='red';this.ctx.textAlign='center';this.ctx.fillText("Error:Invalid data for percentage chart.",this.canvas.width / 2,this.canvas.height / 2);return;} const{items:originalItems}=this.config.data;const options=this.config.options.percentageDistribution;const drawArea=this.drawArea;let itemsToDraw=[...originalItems];if(options.valuesArePercentages){itemsToDraw.forEach(item=>{let directPercentage=(typeof item.value==='number' &&!isNaN(item.value))? item.value:0;item.percentage=Math.max(0,Math.min(100,directPercentage))});}else{const totalValue=itemsToDraw.reduce((sum,item)=>sum+((typeof item.value==='number' &&!isNaN(item.value))? item.value:0),0);itemsToDraw.forEach(item=>{const value=(typeof item.value==='number' &&!isNaN(item.value))? item.value:0;item.percentage=(totalValue===0)? 0:(value / totalValue)* 100;});} if(options.sort==='ascending')itemsToDraw.sort((a,b)=>a.value-b.value);else if(options.sort==='descending')itemsToDraw.sort((a,b)=>b.value-a.value);const plotAreaX=drawArea.x;const plotAreaWidth=drawArea.width;if(plotAreaWidth <=0){console.warn(`PureChart Warning:Not enough width for percentage bar drawing area. PlotAreaWidth:${plotAreaWidth}`);this.ctx.font='12px Arial';this.ctx.fillStyle='orange';this.ctx.textAlign='center';this.ctx.fillText("Not enough space for bars.",this.canvas.width / 2,this.canvas.height / 2);return;} let currentY=drawArea.y+(options.barSpacing / 2);itemsToDraw.forEach((item,index)=>{if(currentY+options.barHeight >drawArea.y+drawArea.height+options.barSpacing)return;const baseColorStr=this._getAutoColor(index,itemsToDraw.length);const filledBarLength=Math.max(0,(item.percentage / 100)* plotAreaWidth);const barTextY=currentY+options.barHeight / 2;const fillLightenPercent=options.fillLightenPercent;const effectiveBorderWidth=options.borderWidth !==undefined ? options.borderWidth:1;if(fillLightenPercent !==undefined &&fillLightenPercent >0 &&typeof fillLightenPercent==='number'){const borderColorStr=baseColorStr;const fillColorStr=this._lightenColor(baseColorStr,fillLightenPercent);if(filledBarLength >0){this.ctx.fillStyle=this._resolveColor(fillColorStr,{x:plotAreaX,y:currentY,w:filledBarLength,h:options.barHeight});this._fillRoundRect(this.ctx,plotAreaX,currentY,filledBarLength,options.barHeight,options.barBorderRadius);if(effectiveBorderWidth >0){this.ctx.strokeStyle=this._resolveColor(borderColorStr,{x:plotAreaX,y:currentY,w:filledBarLength,h:options.barHeight});this.ctx.lineWidth=effectiveBorderWidth;this._strokeRoundRect(this.ctx,plotAreaX,currentY,filledBarLength,options.barHeight,options.barBorderRadius,effectiveBorderWidth);}} }else{const fillColorStr=baseColorStr;this.ctx.fillStyle=this._resolveColor(fillColorStr,{x:plotAreaX,y:currentY,w:filledBarLength,h:options.barHeight});this._fillRoundRect(this.ctx,plotAreaX,currentY,filledBarLength,options.barHeight,options.barBorderRadius);if(effectiveBorderWidth >0){let effectiveBorderColor=options.borderColor;if(effectiveBorderColor===undefined){const resolvedFillColor=this._resolveColor(fillColorStr,{x:plotAreaX,y:currentY,w:filledBarLength,h:options.barHeight});if(typeof resolvedFillColor==='string'){effectiveBorderColor=this._darkenColor(resolvedFillColor,options.borderDarkenPercent !==undefined ? options.borderDarkenPercent:20);}else{effectiveBorderColor='#333333'}} if(effectiveBorderColor &&effectiveBorderColor !=='transparent'){this.ctx.strokeStyle=effectiveBorderColor;this.ctx.lineWidth=effectiveBorderWidth;this._strokeRoundRect(this.ctx,plotAreaX,currentY,filledBarLength,options.barHeight,options.barBorderRadius,effectiveBorderWidth);}} } if(options.labelPosition==='left'){this.ctx.font=options.labelFont;this.ctx.fillStyle=options.labelColor;this.ctx.textAlign='right';this.ctx.textBaseline='middle';this.ctx.fillText(item.label,plotAreaX-10,barTextY,options.maxLabelWidth||undefined);} if(options.labelPosition==='insideStart'){this.ctx.font=options.labelFont;this.ctx.fillStyle=options.labelColor;this.ctx.textAlign='left';this.ctx.textBaseline='middle';if(this.ctx.measureText(item.label).width+10 <filledBarLength){this.ctx.fillText(item.label,plotAreaX+5+(options.barBorderRadius / 2||0),barTextY);}} if(options.showValueText){this.ctx.font=options.valueFont;this.ctx.fillStyle=options.valueColor;this.ctx.textBaseline='middle';const percentageText=`${item.percentage.toFixed(1)}%`;if(options.valuePosition==='right'){this.ctx.textAlign='left';this.ctx.fillText(percentageText,plotAreaX+filledBarLength+(options.valueTextMargin||0),barTextY);}else if(options.valuePosition==='insideEnd'){this.ctx.textAlign='right';if(this.ctx.measureText(percentageText).width+10 <filledBarLength){this.ctx.fillText(percentageText,plotAreaX+filledBarLength-5-(options.barBorderRadius / 2||0),barTextY);}} } const barRectForTooltip={x:plotAreaX,y:currentY,w:filledBarLength,h:options.barHeight};this.interactiveElements.push({type:'percentageDistribution',rect:barRectForTooltip,item:{...item},index:index});currentY+=options.barHeight+options.barSpacing;});} _getBarRect(value,barIndex,groupIndex,numInGroup,groupDrawableWidth,yAxisScaleInfo){const options=this.config.options.bar;const totalItemSpacingFactor=options.itemSpacingFactor *(numInGroup >1 ? numInGroup-1:0);const barActualWidth=(groupDrawableWidth *(1-totalItemSpacingFactor))/ numInGroup;const xInGroup=barIndex *(barActualWidth+barActualWidth * options.itemSpacingFactor);const val=parseFloat(value)||0;const scaleMin=yAxisScaleInfo.min||0;const scale=yAxisScaleInfo.scale||1;const zeroLevelY=this.drawArea.y+this.drawArea.height-((0-scaleMin)* scale);let barHeight=Math.abs(val * scale);let y;if(val >=0){y=zeroLevelY-barHeight;}else{y=zeroLevelY;} if(y <this.drawArea.y){barHeight-=(this.drawArea.y-y);y=this.drawArea.y;} if(y+barHeight >this.drawArea.y+this.drawArea.height){barHeight=(this.drawArea.y+this.drawArea.height)-y;} if(barHeight <0)barHeight=0;return{x:xInGroup,y,w:barActualWidth >0 ? barActualWidth:0,h:barHeight};} _drawBarChart(){const{data,options:chartOptions,type:globalType}=this.config;if(!data.labels||data.labels.length===0||!data.datasets||data.datasets.length===0){return;} const barDatasets=data.datasets.filter(ds=>{const datasetType=ds.type||globalType;return !ds._hidden &&datasetType==='bar';});if(barDatasets.length===0){return} const numLabels=data.labels.length;const numBarDatasets=barDatasets.length;const groupTotalWidth=this.drawArea.width / numLabels;const actualGroupSpacing=groupTotalWidth * chartOptions.bar.groupSpacingFactor;const groupDrawableWidth=groupTotalWidth-actualGroupSpacing;if(groupDrawableWidth <=0 &&numBarDatasets >0){console.warn("PureChart:Not enough width for bar groups.");return;} data.labels.forEach((labelX,i)=>{const groupCanvasXStart=this.drawArea.x+(i * groupTotalWidth)+(actualGroupSpacing / 2);barDatasets.forEach((dataset,j)=>{const yAxisID=dataset.yAxisID||(chartOptions.yAxes &&chartOptions.yAxes.length >0 ? chartOptions.yAxes[0].id:null);if(!yAxisID){console.warn(`PureChart _drawBarChart:Dataset '${dataset.label}' has no yAxisID.`);return} const yAxisScaleInfo=this.yAxisScales[yAxisID];if(!yAxisScaleInfo||!yAxisScaleInfo.scale||yAxisScaleInfo.scale <=0||!isFinite(yAxisScaleInfo.scale)){console.warn(`PureChart _drawBarChart:Invalid Y-axis scale for dataset '${dataset.label}' on yAxisID '${yAxisID}'. Skipping bar.`);return} const originalDatasetIndex=data.datasets.indexOf(dataset);const value=(dataset.values &&dataset.values.length >i &&typeof dataset.values[i]==='number' &&!isNaN(dataset.values[i]))? dataset.values[i]:0;const rectInGroup=this._getBarRect(value,j,i,numBarDatasets,groupDrawableWidth,yAxisScaleInfo);if(rectInGroup.w <=0)return;const finalBarX=groupCanvasXStart+rectInGroup.x;const barRect={x:finalBarX,y:rectInGroup.y,w:rectInGroup.w,h:rectInGroup.h};const defaultBgColor=this.activePalette.defaultDatasetColors[originalDatasetIndex % this.activePalette.defaultDatasetColors.length];const backgroundColorOption=dataset.backgroundColor||defaultBgColor;const backgroundColor=this._resolveColor(backgroundColorOption,barRect);this.ctx.fillStyle=backgroundColor;let borderWidth=dataset.borderWidth;if(borderWidth===undefined)borderWidth=chartOptions.bar.defaultBorderWidth !==undefined ? chartOptions.bar.defaultBorderWidth:1;let borderColor=dataset.borderColor;if(!borderColor &&borderWidth >0){if(typeof backgroundColor==='string'){borderColor=this._darkenColor(backgroundColor,chartOptions.bar.borderDarkenPercent !==undefined ? chartOptions.bar.borderDarkenPercent:20);}else{borderColor=this.activePalette.axisColor}} this.ctx.strokeStyle=borderColor||'transparent';this.ctx.lineWidth=borderWidth;const cornerRadius=chartOptions.bar.topCornerRadius||0;if(cornerRadius >0 &&barRect.h >0){let radiusSpec;if(value >=0){radiusSpec={tl:cornerRadius,tr:cornerRadius,bl:0,br:0};}else{radiusSpec={tl:0,tr:0,bl:cornerRadius,br:cornerRadius};} this._fillRoundRect(this.ctx,barRect.x,barRect.y,barRect.w,barRect.h,radiusSpec);if(borderWidth >0 &&this.ctx.strokeStyle !=='transparent'){this._strokeRoundRect(this.ctx,barRect.x,barRect.y,barRect.w,barRect.h,radiusSpec,borderWidth);}}else{if(barRect.h >0){this.ctx.fillRect(barRect.x,barRect.y,barRect.w,barRect.h);if(borderWidth >0 &&this.ctx.strokeStyle !=='transparent'){this.ctx.strokeRect(barRect.x,barRect.y,barRect.w,barRect.h);}} } this.interactiveElements.push({type:'bar',rect:barRect,xLabel:labelX,dataset:dataset,value:value,datasetIndex:originalDatasetIndex,pointIndex:i});});});} _getControlPointsForSegment(p0,p1,p2,p3,tensionFactor){tensionFactor=(typeof tensionFactor==='number' &&isFinite(tensionFactor))? tensionFactor:0;const t1x=(p2.x-p0.x)* tensionFactor;const t1y=(p2.y-p0.y)* tensionFactor;const t2x=(p3.x-p1.x)* tensionFactor;const t2y=(p3.y-p1.y)* tensionFactor;return{cp1:{x:p1.x+t1x,y:p1.y+t1y},cp2:{x:p2.x-t2x,y:p2.y-t2y}};} _drawLineChart(){const{data:d,options:o,type:globalType}=this.config;const lO=o.line;if(!d.datasets||d.datasets.length===0){return;} d.datasets.forEach((ds,originalDsIndex)=>{const datasetType=ds.type||globalType;if(ds._hidden||(datasetType !=='line' &&datasetType !=='sma')){return} if(!ds.values||!Array.isArray(ds.values)||ds.values.length <1)return;this.ctx.save();const yAxisID=ds.yAxisID||(o.yAxes &&o.yAxes.length >0 ? o.yAxes[0].id:null);if(!yAxisID){console.warn(`PureChart _drawLineChart:Dataset '${ds.label}' has no yAxisID.`);this.ctx.restore();return;} const yAxisScaleInfo=this.yAxisScales[yAxisID];if(!yAxisScaleInfo||!yAxisScaleInfo.scale||yAxisScaleInfo.scale <=0||!isFinite(yAxisScaleInfo.scale)){console.warn(`PureChart _drawLineChart:Invalid Y-axis scale for dataset '${ds.label}' on yAxisID '${yAxisID}'. Skipping line.`);this.ctx.restore();return;} const pts=ds.values.map((v,i)=>{const p=this._getPointPosition(v,i,yAxisScaleInfo);this.interactiveElements.push({type:'point',pos:p,radius:ds.pointRadius !==undefined ? ds.pointRadius:(lO.pointRadius !==undefined ? lO.pointRadius:3),xLabel:d.labels ?(d.labels[i] !==undefined ? String(d.labels[i]):`Index ${i}`):`Index ${i}`,dataset:ds,value:v,datasetIndex:originalDsIndex,pointIndex:i});return p;});if(pts.length===0){this.ctx.restore();return}const userTension=ds.tension !==undefined ? ds.tension:lO.tension;const effectiveLineWidth=ds.lineWidth !==undefined ? ds.lineWidth:lO.lineWidth;const bezierTensionFactor=0.2;if(ds.fill &&pts.length >1){this.ctx.beginPath();const baselineY=this.drawArea.y+this.drawArea.height-((0-(yAxisScaleInfo.min||0))*(yAxisScaleInfo.scale||1));const clampedBaselineY=Math.max(this.drawArea.y,Math.min(this.drawArea.y+this.drawArea.height,baselineY));this.ctx.moveTo(pts[0].x,clampedBaselineY);this.ctx.lineTo(pts[0].x,pts[0].y);if(userTension >0){for(let i=0;i <pts.length-1;i++){const p0=pts[i===0 ? 0:i-1];const p1=pts[i];const p2=pts[i+1];const p3=pts[(i+2 <pts.length)? i+2:i+1];const{cp1,cp2}=this._getControlPointsForSegment(p0,p1,p2,p3,bezierTensionFactor * userTension);this.ctx.bezierCurveTo(cp1.x,cp1.y,cp2.x,cp2.y,p2.x,p2.y)}} else{for(let i=1;i <pts.length;i++){this.ctx.lineTo(pts[i].x,pts[i].y)}}this.ctx.lineTo(pts[pts.length-1].x,clampedBaselineY);this.ctx.closePath();const fillRectPtsY=pts.map(p=>p.y).concat([clampedBaselineY]);const fillRect={x:this.drawArea.x,y:Math.min(...fillRectPtsY),w:this.drawArea.width,h:Math.abs(Math.max(...fillRectPtsY)-Math.min(...fillRectPtsY))};const defaultFillColor=this.activePalette.defaultDatasetColors[originalDsIndex % this.activePalette.defaultDatasetColors.length];const fillBgColorOption=ds.backgroundColor||defaultFillColor;this.ctx.fillStyle=this._resolveColor(fillBgColorOption,fillRect);this.ctx.fill();} if(effectiveLineWidth >0 &&pts.length >0){this.ctx.beginPath();this.ctx.moveTo(pts[0].x,pts[0].y);if(userTension >0 &&pts.length >1){for(let i=0;i <pts.length-1;i++){const p0=pts[i===0 ? 0:i-1];const p1=pts[i];const p2=pts[i+1];const p3=pts[(i+2 <pts.length)? i+2:i+1];const{cp1,cp2}=this._getControlPointsForSegment(p0,p1,p2,p3,bezierTensionFactor * userTension);this.ctx.bezierCurveTo(cp1.x,cp1.y,cp2.x,cp2.y,p2.x,p2.y)}} else if(pts.length >1){for(let i=1;i <pts.length;i++){this.ctx.lineTo(pts[i].x,pts[i].y)}} const defaultBorderColor=this.activePalette.defaultDatasetColors[originalDsIndex % this.activePalette.defaultDatasetColors.length];const borderColorOption=ds.borderColor||defaultBorderColor;this.ctx.strokeStyle=this._resolveColor(borderColorOption,this.drawArea);this.ctx.lineWidth=effectiveLineWidth;let lineDashSet=false;if(ds.borderDash &&Array.isArray(ds.borderDash)&&ds.borderDash.length >0){this.ctx.setLineDash(ds.borderDash);lineDashSet=true;} this.ctx.stroke();if(lineDashSet){this.ctx.setLineDash([])}} const pointRadiusToDraw=ds.pointRadius !==undefined ? ds.pointRadius:(lO.pointRadius !==undefined ? lO.pointRadius:3);if(pointRadiusToDraw >0 &&pts.length >0){pts.forEach((p)=>{const pointRect={x:p.x-pointRadiusToDraw,y:p.y-pointRadiusToDraw,w:pointRadiusToDraw * 2,h:pointRadiusToDraw * 2};let pointFillColorOption=ds.pointColor;if(pointFillColorOption===undefined){if(ds.fill &&ds.backgroundColor){pointFillColorOption=ds.borderColor||this.activePalette.defaultDatasetColors[originalDsIndex % this.activePalette.defaultDatasetColors.length];}else{pointFillColorOption=ds.backgroundColor||ds.borderColor||this.activePalette.defaultDatasetColors[originalDsIndex % this.activePalette.defaultDatasetColors.length];}} this.ctx.fillStyle=this._resolveColor(pointFillColorOption,pointRect);this.ctx.beginPath();const currentPointStyle=ds.pointStyle||lO.pointStyle||'circle';if(currentPointStyle==='square'){this.ctx.rect(pointRect.x,pointRect.y,pointRect.w,pointRect.h)} else{this.ctx.arc(p.x,p.y,pointRadiusToDraw,0,Math.PI * 2)}this.ctx.fill();const pointBorderWidthToDraw=ds.pointBorderWidth !==undefined ? ds.pointBorderWidth:1;if(ds.pointBorderColor &&pointBorderWidthToDraw >0){this.ctx.strokeStyle=this._resolveColor(ds.pointBorderColor,pointRect);this.ctx.lineWidth=pointBorderWidthToDraw;this.ctx.stroke();}});} this.ctx.restore();});} _getPointPosition(value,index,yAxisScaleInfo){const numLabels=this.config.data.labels ? this.config.data.labels.length:0;if(numLabels===0||this.drawArea.width===0){return{x:this.drawArea.x+this.drawArea.width / 2,y:this.drawArea.y+this.drawArea.height / 2}} const xSpacing=(numLabels >1)? this.drawArea.width /(numLabels-1):this.drawArea.width / 2;const x=this.drawArea.x+(index * xSpacing);const yValue=parseFloat(value);if(isNaN(yValue)){return{x:x,y:this.drawArea.y+this.drawArea.height / 2}} const scaleMin=yAxisScaleInfo.min||0;const scale=yAxisScaleInfo.scale||1;let y=this.drawArea.y+this.drawArea.height-((yValue-scaleMin)* scale);if(!isFinite(y)){y=this.drawArea.y+this.drawArea.height / 2} y=Math.max(this.drawArea.y,Math.min(y,this.drawArea.y+this.drawArea.height));return{x,y};} _findXCoordinateForDate(dateString){const labels=this.config.data.labels;const drawArea=this.drawArea;if(!labels||labels.length===0||!drawArea||drawArea.width===undefined){return null;} const targetTime=new Date(dateString).getTime();if(isNaN(targetTime)){return null;} let nearestLabelIndex=-1;let minDiff=Infinity;for(let i=0;i <labels.length;i++){const labelTime=new Date(labels[i]).getTime();if(isNaN(labelTime)){continue} const diff=Math.abs(labelTime-targetTime);if(diff <minDiff){minDiff=diff;nearestLabelIndex=i;}} if(nearestLabelIndex===-1){return null;} const numLabels=labels.length;const xSpacing=(numLabels >1)? drawArea.width /(numLabels-1):drawArea.width / 2;const x=drawArea.x+(nearestLabelIndex * xSpacing);return x;} _getMousePos(event){const rect=this.canvas.getBoundingClientRect();return{x:event.clientX-rect.left,y:event.clientY-rect.top};} _onMouseMove(event){if(!this.tooltipElement||!this.config.options.tooltip.enabled||!this.interactiveElements)return;const mousePos=this._getMousePos(event);const canvasRect=this.canvas.getBoundingClientRect();let bestMatch=null;let minDistanceSq=Infinity;for(let i=this.interactiveElements.length-1;i >=0;i--){const el=this.interactiveElements[i];let isHovered=false;if(el.type==='point' &&el.pos){const radius=el.radius !==undefined ? el.radius:(this.config.options.line.pointRadius !==undefined ? this.config.options.line.pointRadius:3);const hoverRadius=radius+3;const dx=mousePos.x-el.pos.x;const dy=mousePos.y-el.pos.y;const distanceSq=dx * dx+dy * dy;if(distanceSq <=hoverRadius * hoverRadius){if(distanceSq <minDistanceSq){minDistanceSq=distanceSq;bestMatch=el}isHovered=true}}else if((el.type==='bar'||el.type==='percentageDistribution')&&el.rect){if(mousePos.x >=el.rect.x &&mousePos.x <=el.rect.x+el.rect.w &&mousePos.y >=el.rect.y &&mousePos.y <=el.rect.y+el.rect.h){bestMatch=el;break}}} if(bestMatch){let tooltipContentParams;let anchorX,anchorY;let yAxisScaleInfo=null;if(bestMatch.type==='percentageDistribution'){anchorX=bestMatch.rect.x+bestMatch.rect.w / 2+canvasRect.left;anchorY=bestMatch.rect.y+bestMatch.rect.h / 2+canvasRect.top;tooltipContentParams={type:'percentageDistribution', item:bestMatch.item, themePalette:this.activePalette };}else if(bestMatch.type==='bar'||bestMatch.type==='point'){const pointIndex=bestMatch.pointIndex;const xLabel=this.config.data.labels &&this.config.data.labels.length >pointIndex ? String(this.config.data.labels[pointIndex]): (bestMatch.xLabel||`Index ${pointIndex}`);let datasetsForTooltip=[];(this.config.data.datasets||[]).forEach((ds,dsIndex)=>{if(ds._hidden)return;const datasetType=ds.type||this.config.type;if(datasetType==='percentageDistribution')return;const value=(ds.values &&ds.values.length >pointIndex &&ds.values[pointIndex] !==null &&ds.values[pointIndex] !==undefined)? ds.values[pointIndex]:undefined;let resolvedColor=ds.borderColor||ds.backgroundColor;if(Array.isArray(resolvedColor))resolvedColor=resolvedColor[0];if(!resolvedColor){const palette=this.activePalette||PC_LIGHT_THEME_PALETTE;resolvedColor=palette.defaultDatasetColors[dsIndex % palette.defaultDatasetColors.length];} datasetsForTooltip.push({dataset:{label:ds.label||`Dataset ${dsIndex+1}`, color:resolvedColor,originalIndex:dsIndex}, value:value });});if(datasetsForTooltip.length >0){if(bestMatch.type==='point' &&bestMatch.pos){anchorX=bestMatch.pos.x+canvasRect.left;anchorY=bestMatch.pos.y+canvasRect.top;}else if(bestMatch.type==='bar' &&bestMatch.rect){anchorX=bestMatch.rect.x+bestMatch.rect.w / 2+canvasRect.left;anchorY=bestMatch.rect.y+canvasRect.top;}else{anchorX=mousePos.x+canvasRect.left;anchorY=mousePos.y+canvasRect.top;} tooltipContentParams={type:'shared',xLabel:xLabel, datasets:datasetsForTooltip, themePalette:this.activePalette };}} if(tooltipContentParams){tooltipContentParams.anchorX=anchorX;tooltipContentParams.anchorY=anchorY;const currentHoverSignature=JSON.stringify(tooltipContentParams);if(!this.activeTooltipData||this.activeTooltipData.signature !==currentHoverSignature){this.activeTooltipData={signature:currentHoverSignature,data:tooltipContentParams};this._showTooltip(tooltipContentParams);} else{this._positionTooltip(anchorX,anchorY)}this.canvas.style.cursor='pointer';}else{this._onMouseOut()}}else{this._onMouseOut()}} _showTooltip(tooltipData){if(!this.tooltipElement||!this.config.options.tooltip.enabled)return;this.tooltipElement.innerHTML=this.config.options.tooltip.formatter(tooltipData);this.tooltipElement.style.visibility='visible';this._positionTooltip(tooltipData.anchorX,tooltipData.anchorY);} _positionTooltip(anchorPageX,anchorPageY){if(!this.tooltipElement||this.tooltipElement.style.visibility==='hidden')return;this.tooltipElement.style.backgroundColor=this.activePalette.tooltipBgColor;this.tooltipElement.style.color=this.activePalette.tooltipColor;const tooltipRect=this.tooltipElement.getBoundingClientRect();const tooltipWidth=tooltipRect.width;const tooltipHeight=tooltipRect.height;const offset=this.config.options.tooltip.offset||10;const winScrollX=window.scrollX||window.pageXOffset;const winScrollY=window.scrollY||window.pageYOffset;const viewportWidth=window.innerWidth;const viewportHeight=window.innerHeight;let docLeft=anchorPageX+winScrollX-(tooltipWidth / 2);let docTop=anchorPageY+winScrollY-tooltipHeight-offset;if((docTop-winScrollY)<5){docTop=anchorPageY+winScrollY+offset;} if((docTop-winScrollY+tooltipHeight)>(viewportHeight-5)){let tempTopAbove=anchorPageY+winScrollY-tooltipHeight-offset;if((tempTopAbove-winScrollY)>=5){docTop=tempTopAbove;}else{docTop=winScrollY+viewportHeight-tooltipHeight-5;if(docTop-winScrollY <5)docTop=winScrollY+5;}} if((docLeft-winScrollX)<5){docLeft=winScrollX+5;} if((docLeft-winScrollX+tooltipWidth)>(viewportWidth-5)){docLeft=winScrollX+viewportWidth-tooltipWidth-5;} if((docLeft-winScrollX)<5)docLeft=winScrollX+5;this.tooltipElement.style.left=`${docLeft}px`;this.tooltipElement.style.top=`${docTop}px`;} _onMouseOut(){if(this.tooltipElement &&this.config.options.tooltip.enabled){this.tooltipElement.style.visibility='hidden'} this.activeTooltipData=null;if(this.canvas){this.canvas.style.cursor='default'}} _drawAnnotations(){const allAnnotations=this.config.options.annotations;if(!allAnnotations||!Array.isArray(allAnnotations)||allAnnotations.length===0|| !this.config.options.yAxes||this.config.options.yAxes.length===0|| !this.yAxisScales||Object.keys(this.yAxisScales).length===0){return;} const defaultYAxisId=this.config.options.yAxes[0].id;this.ctx.save();allAnnotations.forEach(annotation=>{if(annotation.type !=='line'||annotation.mode !=='horizontal'){return} const targetYAxisId=annotation.yAxisID||defaultYAxisId;const currentAxisScale=this.yAxisScales[targetYAxisId];if(!currentAxisScale||!currentAxisScale.scale||currentAxisScale.scale <=0||!isFinite(currentAxisScale.scale)|| !currentAxisScale.axisConfig||!currentAxisScale.axisConfig.display){return} const{min:axisMin,max:axisMax,scale:axisScale}=currentAxisScale;let y=null;if(annotation.value !==undefined){y=this.drawArea.y+this.drawArea.height-((annotation.value-axisMin)* axisScale);}else if(annotation.percentage !==undefined &&typeof annotation.percentage==='number'){const yRange=axisMax-axisMin;let yValueForPercentage;if(yRange===0){yValueForPercentage=axisMin}else{yValueForPercentage=axisMin+(annotation.percentage / 100)* yRange;} y=this.drawArea.y+this.drawArea.height-((yValueForPercentage-axisMin)* axisScale);} if(y===null||isNaN(y)||!isFinite(y)){console.warn(`PureChart Annotation:Could not determine Y position for annotation on Y-axis ID '${targetYAxisId}'.`,annotation);return;} y=Math.max(this.drawArea.y,Math.min(y,this.drawArea.y+this.drawArea.height));this.ctx.save();this.ctx.beginPath();this.ctx.moveTo(this.drawArea.x,y);this.ctx.lineTo(this.drawArea.x+this.drawArea.width,y);this.ctx.strokeStyle=annotation.borderColor||this.activePalette.gridColor;this.ctx.lineWidth=annotation.borderWidth||1;let lineDashSet=false;if(annotation.borderDash &&Array.isArray(annotation.borderDash)&&annotation.borderDash.length >0){this.ctx.setLineDash(annotation.borderDash);lineDashSet=true;} this.ctx.stroke();if(lineDashSet){this.ctx.setLineDash([]);} this.ctx.restore();if(annotation.label &&annotation.label.text){this.ctx.save();const labelOptions=annotation.label;const defaultFont=this.config.options.font||'10px Arial';this.ctx.font=labelOptions.font||defaultFont;const labelColor=labelOptions.color||currentAxisScale.axisConfig.color||this.activePalette.axisColor;this.ctx.fillStyle=labelColor;let labelX,labelY;let textAlign='right';let textBaseline='bottom';const rawPadding=labelOptions.padding===undefined ? 2:labelOptions.padding;const padding={x:typeof rawPadding==='object' ?(rawPadding.x||0):rawPadding, y:typeof rawPadding==='object' ?(rawPadding.y||0):rawPadding };const position=labelOptions.position||'right';switch(position){case 'left': textAlign='left';textBaseline='bottom';labelX=this.drawArea.x+padding.x;labelY=y-padding.y;break;case 'top-left': textAlign='left';textBaseline='bottom';labelX=this.drawArea.x+padding.x;labelY=y-padding.y;break;case 'bottom-left': textAlign='left';textBaseline='top';labelX=this.drawArea.x+padding.x;labelY=y+padding.y;break;case 'top-right': textAlign='right';textBaseline='bottom';labelX=this.drawArea.x+this.drawArea.width-padding.x;labelY=y-padding.y;break;case 'bottom-right': textAlign='right';textBaseline='top';labelX=this.drawArea.x+this.drawArea.width-padding.x;labelY=y+padding.y;break;case 'center':textAlign='center';textBaseline='bottom';labelX=this.drawArea.x+this.drawArea.width / 2;labelY=y-padding.y;break;case 'right':default: textAlign='right';textBaseline='bottom';labelX=this.drawArea.x+this.drawArea.width-padding.x;labelY=y-padding.y;break;} this.ctx.textAlign=textAlign;this.ctx.textBaseline=textBaseline;if(labelOptions.backgroundColor){const textMetrics=this.ctx.measureText(labelOptions.text);const fontHeight=parseInt(this.ctx.font.match(/(d+)px/)?.[1]||'10');const bgWidth=textMetrics.width+2 * padding.x;const bgHeight=fontHeight+2 * padding.y;let bgX=labelX;if(textAlign==='right')bgX=labelX-textMetrics.width-padding.x;else if(textAlign==='center')bgX=labelX-textMetrics.width/2-padding.x;else bgX=labelX-padding.x;let bgY=labelY;if(textBaseline==='bottom')bgY=labelY-fontHeight-padding.y;else if(textBaseline==='middle')bgY=labelY-fontHeight/2-padding.y;else bgY=labelY-padding.y;this.ctx.fillStyle=labelOptions.backgroundColor;this.ctx.fillRect(bgX,bgY,bgWidth,bgHeight);this.ctx.fillStyle=labelColor;} this.ctx.fillText(labelOptions.text,labelX,labelY);this.ctx.restore();}});this.ctx.restore()} _drawPeriodHighlights(){if(!this.showPeriodHighlights){return;} const periodHighlightsConfig=this.config.options.periodHighlights;if(!periodHighlightsConfig||!periodHighlightsConfig.periods||periodHighlightsConfig.periods.length===0){return;} const drawArea=this.drawArea;if(!drawArea)return;periodHighlightsConfig.periods.forEach(period=>{const startX=this._findXCoordinateForDate(period.startDate);const endX=this._findXCoordinateForDate(period.endDate);if(startX===null||endX===null||startX >=endX){return;} const defaultStyle=periodHighlightsConfig.defaultStyle||{};const periodStyle=period.style||{};const finalStyle={...defaultStyle, ...periodStyle, label:{...(defaultStyle.label||{}), ...(periodStyle.label||{}) }};if(finalStyle.fillColor){this.ctx.fillStyle=finalStyle.fillColor;this.ctx.fillRect(startX,drawArea.y,endX-startX,drawArea.height);} if(finalStyle.borderWidth >0 &&finalStyle.borderColor){this.ctx.strokeStyle=finalStyle.borderColor;this.ctx.lineWidth=finalStyle.borderWidth;this.ctx.strokeRect(startX,drawArea.y,endX-startX,drawArea.height);} if(period.name &&finalStyle.label){this.ctx.save();this.ctx.font=finalStyle.label.font||'10px Arial';this.ctx.fillStyle=finalStyle.label.color||'#000000';this.ctx.textAlign=finalStyle.label.textAlign||'center';this.ctx.textBaseline='middle';let labelX,labelY;const rectCenterX=startX+(endX-startX)/ 2;const rectCenterY=drawArea.y+drawArea.height / 2;const offset=finalStyle.label.offset||5;switch(finalStyle.label.position){case 'center': labelX=rectCenterX;labelY=rectCenterY;break;case 'below': labelX=rectCenterX;labelY=drawArea.y+drawArea.height+offset+(this.ctx.measureText('M').width / 2);if(finalStyle.label.angle &&(finalStyle.label.angle % 360 !==0)){labelY+=Math.abs(Math.sin(finalStyle.label.angle * Math.PI / 180)*(this.ctx.measureText(period.name).width /2));} break;case 'above': default: labelX=rectCenterX;labelY=drawArea.y-offset-(this.ctx.measureText('M').width / 2);if(finalStyle.label.angle &&(finalStyle.label.angle % 360 !==0)){labelY-=Math.abs(Math.sin(finalStyle.label.angle * Math.PI / 180)*(this.ctx.measureText(period.name).width /2));} break;} this.ctx.translate(labelX,labelY);this.ctx.rotate((finalStyle.label.angle||0)* Math.PI / 180);this.ctx.fillText(period.name,0,0);this.ctx.restore();}});} _preprocessDatasetValues(){if(!this.config.data||!this.config.data.datasets)return;const datasets=this.config.data.datasets;const numLabels=this.config.data.labels ? this.config.data.labels.length:0;datasets.forEach((ds,index)=>{if(ds.type==='sma'){let validSma=true;let sourceDs=null;if(typeof ds.sourceDatasetIndex !=='number'||ds.sourceDatasetIndex <0||ds.sourceDatasetIndex >=datasets.length){console.warn(`PureChart SMA Error:Dataset ${index}('${ds.label}')has invalid sourceDatasetIndex ${ds.sourceDatasetIndex}.`);validSma=false;}else{sourceDs=datasets[ds.sourceDatasetIndex];if(sourceDs.type==='sma'){console.warn(`PureChart SMA Error:Dataset ${index}('${ds.label}')sourceDatasetIndex ${ds.sourceDatasetIndex}('${sourceDs.label}')is another SMA. Chaining SMAs is not supported.`);validSma=false;sourceDs=null} if(ds.sourceDatasetIndex===index){console.warn(`PureChart SMA Error:Dataset ${index}('${ds.label}')sourceDatasetIndex cannot be itself.`);validSma=false;sourceDs=null;}} if(typeof ds.period !=='number'||ds.period <=0){console.warn(`PureChart SMA Error:Dataset ${index}('${ds.label}')has invalid period ${ds.period}.`);validSma=false;} if(validSma &&sourceDs){if(sourceDs._hidden){ds.values=numLabels >0 ? new Array(numLabels).fill(null):[];}else if(!sourceDs.values||sourceDs.values.length===0){console.warn(`PureChart SMA Error:Source dataset ${ds.sourceDatasetIndex}('${sourceDs.label}')for SMA dataset ${index}('${ds.label}')has no values.`);ds.values=numLabels >0 ? new Array(numLabels).fill(null):[];}else{ds.values=PureChart._calculateSMA(sourceDs.values,ds.period);if(ds.values.length===0 &&sourceDs.values.length >0){console.warn(`PureChart SMA Warning:Dataset ${index}('${ds.label}')period ${ds.period}is greater than source data length ${sourceDs.values.length}. Resulting in empty SMA.`);}} }else{ds.values=numLabels >0 ? new Array(numLabels).fill(null):[]}} });} destroy(){if(!this.isValid)return;if(this.canvas){if(this.config &&this.config.options &&this.config.options.tooltip &&this.config.options.tooltip.enabled){if(this._boundOnMouseMove)this.canvas.removeEventListener('mousemove',this._boundOnMouseMove);if(this._boundOnMouseOut){this.canvas.removeEventListener('mouseout',this._boundOnMouseOut);this.canvas.removeEventListener('mouseleave',this._boundOnMouseOut);}} if(this._boundOnCanvasClick)this.canvas.removeEventListener('click',this._boundOnCanvasClick);} if(this.tooltipElement){if(this.tooltipElement.parentElement){this.tooltipElement.remove()} this.tooltipElement=null;} if(this.resizeObserver){this.resizeObserver.disconnect();this.resizeObserver=null;} if(this.debouncedResize){this.debouncedResize=null;} this.ctx=null;this.canvas=null;if(this.config){this.config=null;} this.interactiveElements=[];this.interactiveLegendItems=[];this.activeTooltipData=null;this.yAxisScales=null;this.drawArea=null;this._boundOnMouseMove=null;this._boundOnMouseOut=null;this._boundOnCanvasClick=null;this.isValid=false}} 